{
    "sourceFile": "audio.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1757088670550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1757088682748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,10 +107,9 @@\n \n     file_types = {\n         \".mp3\": \"Audio\",\n         \".wav\": \"Audio\",\n-        \n-        \".m4a\": \"Audio\",\n+         \".m4a\": \"Audio\",\n     }\n \n     for directory in directories:\n         for root, dirs, files in os.walk(directory):\n"
                },
                {
                    "date": 1757089158391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,30 +2,25 @@\n import os\n import re\n from datetime import datetime\n \n-import config  # Import the configuration\n from mutagen.easyid3 import EasyID3\n from mutagen.mp3 import MP3\n \n # Constants\n LAST_DIRECTORY_FILE = \"audio.txt\"\n \n-# Function to get the creation date of a file\n-\n-\n def get_creation_date(filepath):\n+    \"\"\"Get the creation date of a file.\"\"\"\n     try:\n-        return datetime.fromtimestamp(os.path.getctime(filepath)).strftime(\"%m-%d-%y\")\n+        timestamp = os.path.getctime(filepath)\n+        return datetime.fromtimestamp(timestamp).strftime(\"%m-%d-%y\")\n     except Exception as e:\n         print(f\"Error getting creation date for {filepath}: {e}\")\n         return \"Unknown\"\n \n-\n-# Function to extract metadata from an audio file using Mutagen\n-\n-\n def get_audio_metadata(filepath):\n+    \"\"\"Extract metadata from an audio file using Mutagen.\"\"\"\n     try:\n         audio = MP3(filepath, ID3=EasyID3)\n         duration = audio.info.length\n         return os.path.getsize(filepath), duration\n"
                },
                {
                    "date": 1757089165508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,15 +25,12 @@\n         duration = audio.info.length\n         return os.path.getsize(filepath), duration\n     except Exception as e:\n         print(f\"Error getting audio metadata for {filepath}: {e}\")\n-    return None, None\n+        return None, None\n \n-\n-# Function to format file size\n-\n-\n def format_file_size(size_in_bytes):\n+    \"\"\"Format file size into a human-readable string.\"\"\"\n     try:\n         thresholds = [\n             (1024**4, \"TB\"),\n             (1024**3, \"GB\"),\n@@ -42,19 +39,15 @@\n             (1024**0, \"B\"),\n         ]\n         for factor, suffix in thresholds:\n             if size_in_bytes >= factor:\n-                break\n-        return f\"{size_in_bytes / factor:.2f} {suffix}\"\n+                return f\"{size_in_bytes / factor:.2f} {suffix}\"\n     except Exception as e:\n         print(f\"Error formatting file size: {e}\")\n-        return \"Unknown\"\n+    return \"Unknown\"\n \n-\n-# Function to format duration in H:M:S or M:S\n-\n-\n def format_duration(duration_in_seconds):\n+    \"\"\"Format duration in H:M:S or M:S.\"\"\"\n     if duration_in_seconds is None:\n         return \"Unknown\"\n     try:\n         hours = int(duration_in_seconds // 3600)\n"
                },
                {
                    "date": 1757089172610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,23 +54,19 @@\n         minutes = int((duration_in_seconds % 3600) // 60)\n         seconds = int(duration_in_seconds % 60)\n         if hours > 0:\n             return f\"{hours}:{minutes:02d}:{seconds:02d}\"\n-        else:\n-            return f\"{minutes}:{seconds:02d}\"\n+        return f\"{minutes}:{seconds:02d}\"\n     except Exception as e:\n         print(f\"Error formatting duration: {e}\")\n         return \"Unknown\"\n \n-\n-# Function to generate a dry run CSV for organizing audio files\n-\n-\n def generate_dry_run_csv(directories, csv_path):\n+    \"\"\"Generate a dry run CSV for organizing audio files.\"\"\"\n     rows = []\n-\n-    # Regex patterns for exclusions\n     excluded_patterns = [\n+        r\"^\\..*\", r\".*\\/venv\\/.*\", r\".*\\/\\.venv\\/.*\", r\".*\\/my_global_venv\\/.*\",\n+        r\".*\\/simplegallery\\/.*\", r\".*\\/avatararts\\/.*\", r\".*\\/github\\/.*\",\n         r\"^\\..*\",  # Hidden files and directories\n         r\".*\\/venv\\/.*\",  # venv directories\n         r\".*\\/\\.venv\\/.*\",  # .venv directories\n         r\".*\\/my_global_venv\\/.*\",  # venv directories\n"
                },
                {
                    "date": 1757089189400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,98 +65,49 @@\n     rows = []\n     excluded_patterns = [\n         r\"^\\..*\", r\".*\\/venv\\/.*\", r\".*\\/\\.venv\\/.*\", r\".*\\/my_global_venv\\/.*\",\n         r\".*\\/simplegallery\\/.*\", r\".*\\/avatararts\\/.*\", r\".*\\/github\\/.*\",\n-        r\"^\\..*\",  # Hidden files and directories\n-        r\".*\\/venv\\/.*\",  # venv directories\n-        r\".*\\/\\.venv\\/.*\",  # .venv directories\n-        r\".*\\/my_global_venv\\/.*\",  # venv directories\n-        r\".*\\/simplegallery\\/.*\",\n-        r\".*\\/avatararts\\/.*\",\n-        r\".*\\/github\\/.*\",\n-        r\".*\\/Documents\\/gitHub\\/.*\",  # Specific gitHub directory\n-        r\".*\\/\\.my_global_venv\\/.*\",  # .venv directories\n-        r\".*\\/node\\/.*\",  # Any directory named node\n-        r\".*\\/Movies\\/CapCut\\/.*\",\n-        r\".*\\/miniconda3\\/.*\",\n-        r\".*\\/Movies\\/movavi\\/.*\",\n-        r\".*\\/env\\/.*\",  # env directories\n-        r\".*\\/\\.env\\/.*\",  # .env directories\n-        r\".*\\/Library\\/.*\",  # Library directories\n-        r\".*\\/\\.config\\/.*\",  # .config directories\n-        r\".*\\/\\.spicetify\\/.*\",  # .spicetify directories\n-        r\".*\\/\\.gem\\/.*\",  # .gem directories\n-        r\".*\\/\\.zprofile\\/.*\",  # .zprofile directories\n-        r\"^.*\\/\\..*\",  # Any file or directory starting with a dot\n+        r\".*\\/Documents\\/gitHub\\/.*\", r\".*\\/\\.my_global_venv\\/.*\", r\".*\\/node\\/.*\",\n+        r\".*\\/Movies\\/CapCut\\/.*\", r\".*\\/miniconda3\\/.*\", r\".*\\/Movies\\/movavi\\/.*\",\n+        r\".*\\/env\\/.*\", r\".*\\/\\.env\\/.*\", r\".*\\/Library\\/.*\", r\".*\\/\\.config\\/.*\",\n+        r\".*\\/\\.spicetify\\/.*\", r\".*\\/\\.gem\\/.*\", r\".*\\/\\.zprofile\\/.*\", r\"^.*\\/\\..*\"\n     ]\n+    file_types = {\".mp3\": \"Audio\", \".wav\": \"Audio\", \".m4a\": \"Audio\"}\n \n-    file_types = {\n-        \".mp3\": \"Audio\",\n-        \".wav\": \"Audio\",\n-         \".m4a\": \"Audio\",\n-    }\n-\n     for directory in directories:\n         for root, dirs, files in os.walk(directory):\n-            # Skip hidden directories and venv directories using regex\n-            dirs[:] = [\n-                d\n-                for d in dirs\n-                if not any(\n-                    re.match(pattern, os.path.join(root, d))\n-                    for pattern in excluded_patterns\n-                )\n-            ]\n-\n+            dirs[:] = [d for d in dirs if not any(re.match(pattern, os.path.join(root, d)) for pattern in excluded_patterns)]\n             for file in files:\n                 file_path = os.path.join(root, file)\n-\n-                # Skip files that match the excluded patterns\n                 if any(re.match(pattern, file_path) for pattern in excluded_patterns):\n                     continue\n-\n                 file_ext = os.path.splitext(file)[1].lower()\n-\n-                # Add file to rows if it matches the logical file types\n                 if file_ext in file_types:\n                     creation_date = get_creation_date(file_path)\n                     file_size, duration = get_audio_metadata(file_path)\n-                    if file_size is None:\n-                        file_size = \"Unknown\"\n-                    else:\n-                        file_size = format_file_size(file_size)\n+                    file_size = format_file_size(file_size) if file_size is not None else \"Unknown\"\n                     formatted_duration = format_duration(duration)\n-                    rows.append(\n-                        [file, formatted_duration, file_size, creation_date, file_path]\n-                    )\n+                    rows.append([file, formatted_duration, file_size, creation_date, file_path])\n \n     write_csv(csv_path, rows)\n \n-\n def write_csv(csv_path, rows):\n+    \"\"\"Write rows to a CSV file.\"\"\"\n     with open(csv_path, \"w\", newline=\"\") as csvfile:\n-        fieldnames = [\n-            \"Filename\",\n-            \"Duration\",\n-            \"File Size\",\n-            \"Creation Date\",\n-            \"Original Path\",\n-        ]\n+        fieldnames = [\"Filename\", \"Duration\", \"File Size\", \"Creation Date\", \"Original Path\"]\n         writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n         writer.writeheader()\n         for row in rows:\n-            writer.writerow(\n-                {\n-                    \"Filename\": row[0],\n-                    \"Duration\": row[1],\n-                    \"File Size\": row[2],\n-                    \"Creation Date\": row[3],\n-                    \"Original Path\": row[4],\n-                }\n-            )\n+            writer.writerow({\n+                \"Filename\": row[0],\n+                \"Duration\": row[1],\n+                \"File Size\": row[2],\n+                \"Creation Date\": row[3],\n+                \"Original Path\": row[4],\n+            })\n \n-\n def get_unique_file_path(base_path):\n+    \"\"\"Generate a unique file path by appending a counter if the path exists.\"\"\"\n     if not os.path.exists(base_path):\n         return base_path\n \n     base, ext = os.path.splitext(base_path)\n"
                },
                {
                    "date": 1757089197705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,45 +117,34 @@\n         if not os.path.exists(new_path):\n             return new_path\n         counter += 1\n \n-\n def save_last_directory(directory):\n+    \"\"\"Save the last used directory to a file.\"\"\"\n     with open(LAST_DIRECTORY_FILE, \"w\") as file:\n         file.write(directory)\n \n-\n def load_last_directory():\n+    \"\"\"Load the last used directory from a file.\"\"\"\n     if os.path.exists(LAST_DIRECTORY_FILE):\n         with open(LAST_DIRECTORY_FILE, \"r\") as file:\n             return file.read().strip()\n     return None\n \n-\n if __name__ == \"__main__\":\n     directories = []\n     last_directory = load_last_directory()\n \n     while True:\n         if last_directory:\n-            use_last = (\n-                input(\n-                    f\"Do you want to use the last directory '{last_directory}'? (Y/N): \"\n-                )\n-                .strip()\n-                .lower()\n-            )\n+            use_last = input(f\"Do you want to use the last directory '{last_directory}'? (Y/N): \").strip().lower()\n             if use_last == \"y\":\n                 directories.append(last_directory)\n                 break\n             else:\n-                source_directory = input(\n-                    \"Please enter a new source directory to scan for audio files: \"\n-                ).strip()\n+                source_directory = input(\"Please enter a new source directory to scan for audio files: \").strip()\n         else:\n-            source_directory = input(\n-                \"Please enter a source directory to scan for audio files: \"\n-            ).strip()\n+            source_directory = input(\"Please enter a source directory to scan for audio files: \").strip()\n \n         if source_directory == \"\":\n             break\n         if os.path.isdir(source_directory):\n"
                }
            ],
            "date": 1757088670550,
            "name": "Commit-0",
            "content": "import csv\nimport os\nimport re\nfrom datetime import datetime\n\nimport config  # Import the configuration\nfrom mutagen.easyid3 import EasyID3\nfrom mutagen.mp3 import MP3\n\n# Constants\nLAST_DIRECTORY_FILE = \"audio.txt\"\n\n# Function to get the creation date of a file\n\n\ndef get_creation_date(filepath):\n    try:\n        return datetime.fromtimestamp(os.path.getctime(filepath)).strftime(\"%m-%d-%y\")\n    except Exception as e:\n        print(f\"Error getting creation date for {filepath}: {e}\")\n        return \"Unknown\"\n\n\n# Function to extract metadata from an audio file using Mutagen\n\n\ndef get_audio_metadata(filepath):\n    try:\n        audio = MP3(filepath, ID3=EasyID3)\n        duration = audio.info.length\n        return os.path.getsize(filepath), duration\n    except Exception as e:\n        print(f\"Error getting audio metadata for {filepath}: {e}\")\n    return None, None\n\n\n# Function to format file size\n\n\ndef format_file_size(size_in_bytes):\n    try:\n        thresholds = [\n            (1024**4, \"TB\"),\n            (1024**3, \"GB\"),\n            (1024**2, \"MB\"),\n            (1024**1, \"KB\"),\n            (1024**0, \"B\"),\n        ]\n        for factor, suffix in thresholds:\n            if size_in_bytes >= factor:\n                break\n        return f\"{size_in_bytes / factor:.2f} {suffix}\"\n    except Exception as e:\n        print(f\"Error formatting file size: {e}\")\n        return \"Unknown\"\n\n\n# Function to format duration in H:M:S or M:S\n\n\ndef format_duration(duration_in_seconds):\n    if duration_in_seconds is None:\n        return \"Unknown\"\n    try:\n        hours = int(duration_in_seconds // 3600)\n        minutes = int((duration_in_seconds % 3600) // 60)\n        seconds = int(duration_in_seconds % 60)\n        if hours > 0:\n            return f\"{hours}:{minutes:02d}:{seconds:02d}\"\n        else:\n            return f\"{minutes}:{seconds:02d}\"\n    except Exception as e:\n        print(f\"Error formatting duration: {e}\")\n        return \"Unknown\"\n\n\n# Function to generate a dry run CSV for organizing audio files\n\n\ndef generate_dry_run_csv(directories, csv_path):\n    rows = []\n\n    # Regex patterns for exclusions\n    excluded_patterns = [\n        r\"^\\..*\",  # Hidden files and directories\n        r\".*\\/venv\\/.*\",  # venv directories\n        r\".*\\/\\.venv\\/.*\",  # .venv directories\n        r\".*\\/my_global_venv\\/.*\",  # venv directories\n        r\".*\\/simplegallery\\/.*\",\n        r\".*\\/avatararts\\/.*\",\n        r\".*\\/github\\/.*\",\n        r\".*\\/Documents\\/gitHub\\/.*\",  # Specific gitHub directory\n        r\".*\\/\\.my_global_venv\\/.*\",  # .venv directories\n        r\".*\\/node\\/.*\",  # Any directory named node\n        r\".*\\/Movies\\/CapCut\\/.*\",\n        r\".*\\/miniconda3\\/.*\",\n        r\".*\\/Movies\\/movavi\\/.*\",\n        r\".*\\/env\\/.*\",  # env directories\n        r\".*\\/\\.env\\/.*\",  # .env directories\n        r\".*\\/Library\\/.*\",  # Library directories\n        r\".*\\/\\.config\\/.*\",  # .config directories\n        r\".*\\/\\.spicetify\\/.*\",  # .spicetify directories\n        r\".*\\/\\.gem\\/.*\",  # .gem directories\n        r\".*\\/\\.zprofile\\/.*\",  # .zprofile directories\n        r\"^.*\\/\\..*\",  # Any file or directory starting with a dot\n    ]\n\n    file_types = {\n        \".mp3\": \"Audio\",\n        \".wav\": \"Audio\",\n        \n        \".m4a\": \"Audio\",\n    }\n\n    for directory in directories:\n        for root, dirs, files in os.walk(directory):\n            # Skip hidden directories and venv directories using regex\n            dirs[:] = [\n                d\n                for d in dirs\n                if not any(\n                    re.match(pattern, os.path.join(root, d))\n                    for pattern in excluded_patterns\n                )\n            ]\n\n            for file in files:\n                file_path = os.path.join(root, file)\n\n                # Skip files that match the excluded patterns\n                if any(re.match(pattern, file_path) for pattern in excluded_patterns):\n                    continue\n\n                file_ext = os.path.splitext(file)[1].lower()\n\n                # Add file to rows if it matches the logical file types\n                if file_ext in file_types:\n                    creation_date = get_creation_date(file_path)\n                    file_size, duration = get_audio_metadata(file_path)\n                    if file_size is None:\n                        file_size = \"Unknown\"\n                    else:\n                        file_size = format_file_size(file_size)\n                    formatted_duration = format_duration(duration)\n                    rows.append(\n                        [file, formatted_duration, file_size, creation_date, file_path]\n                    )\n\n    write_csv(csv_path, rows)\n\n\ndef write_csv(csv_path, rows):\n    with open(csv_path, \"w\", newline=\"\") as csvfile:\n        fieldnames = [\n            \"Filename\",\n            \"Duration\",\n            \"File Size\",\n            \"Creation Date\",\n            \"Original Path\",\n        ]\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        for row in rows:\n            writer.writerow(\n                {\n                    \"Filename\": row[0],\n                    \"Duration\": row[1],\n                    \"File Size\": row[2],\n                    \"Creation Date\": row[3],\n                    \"Original Path\": row[4],\n                }\n            )\n\n\ndef get_unique_file_path(base_path):\n    if not os.path.exists(base_path):\n        return base_path\n\n    base, ext = os.path.splitext(base_path)\n    counter = 1\n    while True:\n        new_path = f\"{base}_{counter}{ext}\"\n        if not os.path.exists(new_path):\n            return new_path\n        counter += 1\n\n\ndef save_last_directory(directory):\n    with open(LAST_DIRECTORY_FILE, \"w\") as file:\n        file.write(directory)\n\n\ndef load_last_directory():\n    if os.path.exists(LAST_DIRECTORY_FILE):\n        with open(LAST_DIRECTORY_FILE, \"r\") as file:\n            return file.read().strip()\n    return None\n\n\nif __name__ == \"__main__\":\n    directories = []\n    last_directory = load_last_directory()\n\n    while True:\n        if last_directory:\n            use_last = (\n                input(\n                    f\"Do you want to use the last directory '{last_directory}'? (Y/N): \"\n                )\n                .strip()\n                .lower()\n            )\n            if use_last == \"y\":\n                directories.append(last_directory)\n                break\n            else:\n                source_directory = input(\n                    \"Please enter a new source directory to scan for audio files: \"\n                ).strip()\n        else:\n            source_directory = input(\n                \"Please enter a source directory to scan for audio files: \"\n            ).strip()\n\n        if source_directory == \"\":\n            break\n        if os.path.isdir(source_directory):\n            directories.append(source_directory)\n            save_last_directory(source_directory)\n        else:\n            print(f\"'{source_directory}' is not a valid directory. Please try again.\")\n\n    if directories:\n        current_date = datetime.now().strftime(\"%m-%d-%H:%M\")\n        csv_output_path = os.path.join(os.getcwd(), f\"audio-{current_date}.csv\")\n        csv_output_path = get_unique_file_path(csv_output_path)\n\n        generate_dry_run_csv(directories, csv_output_path)\n        print(f\"Dry run completed. Output saved to {csv_output_path}\")\n    else:\n        print(\"No directories were provided to scan.\")\n"
        }
    ]
}