{
    "sourceFile": "batch-info-python.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1757089222998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1757089234062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,59 +21,43 @@\n     if \"backup\" in content_lower or \"autopep8\" in content_lower:\n         return \"File Backup and Autopep8 Formatting\"\n     if \"scan\" in content_lower or \"directory\" in content_lower:\n         return \"Directory Scan for Large Images\"\n-    if (\n-        \"cleanup\" in content.lower()\n-        or \"virtualenv\" in content.lower()\n-        or \"venv\" in content.lower()\n-    ):\n+    if \"cleanup\" in content_lower or \"virtualenv\" in content_lower or \"venv\" in content_lower:\n         return \"Virtual Environment Cleanup Manager\"\n-    if \"google\" in content.lower() or \"drive\" in content.lower():\n+    if \"google\" in content_lower or \"drive\" in content_lower:\n         return \"Google Drive Link Converter\"\n-    if \"quiz\" in file_name.lower():\n-        if \"tts\" in file_name.lower():\n-            return \"Trivia Quiz Generator\"\n-        else:\n-            return \"Image Upscaling and YouTube Content Generator\"\n-    if \"vance\" in file_name.lower() or \"ai\" in content.lower():\n+    if \"quiz\" in file_name_lower:\n+        return \"Trivia Quiz Generator\" if \"tts\" in file_name_lower else \"Image Upscaling and YouTube Content Generator\"\n+    if \"vance\" in file_name_lower or \"ai\" in content_lower:\n         return \"Image Upscaling with Vance AI API\"\n-    if \"speech\" in content.lower() or \"text-to-speech\" in content.lower():\n+    if \"speech\" in content_lower or \"text-to-speech\" in content_lower:\n         return \"Text-to-Speech Speech Generation\"\n-    if \"transcribe\" in content.lower() or \"audio\" in content.lower():\n+    if \"transcribe\" in content_lower or \"audio\" in content_lower:\n         return \"Speech Transcription\"\n-    if \"analyze\" in content.lower() or \"lyrics\" in content.lower():\n+    if \"analyze\" in content_lower or \"lyrics\" in content_lower:\n         return \"Lyrics Analyzer Assistant\"\n \n-    # Default category if none matched\n     return \"General Script\"\n \n-\n # Function to generate documentation using pydocgen\n def generate_pydocgen(file_path):\n     try:\n-        # Generate documentation using the pydocgen command-line tool\n         result = subprocess.run([\"pydocgen\", file_path], capture_output=True, text=True)\n-        # Return the generated documentation if successful\n         if result.returncode == 0:\n             return result.stdout\n-        else:\n-            print(f\"pydocgen failed for {file_path}: {result.stderr}\")\n-            return \"Documentation generation failed\"\n+        print(f\"pydocgen failed for {file_path}: {result.stderr}\")\n     except Exception as e:\n         print(f\"Error generating documentation for {file_path}: {e}\")\n-        return \"Documentation generation failed\"\n+    return \"Documentation generation failed\"\n \n-\n # Function to get script titles using OpenAI API\n def get_openai_batch_titles(script_contents):\n-    if not openai.api_key:\n-        raise ValueError(\n-            \"OpenAI API key is missing. Make sure it's set in the .env file.\"\n-        )\n+    if not client.api_key:\n+        raise ValueError(\"OpenAI API key is missing. Make sure it's set in the .env file.\")\n \n-    # Prepare messages for the batch request\n     messages = [\n+        {\"role\": \"system\", \"content\": \"You are an expert Python programmer. Suggest appropriate titles for the following scripts.\"},\n         {\n             \"role\": \"system\",\n             \"content\": \"You are an expert Python programmer. Suggest appropriate titles for the following scripts.\",\n         },\n"
                },
                {
                    "date": 1757089241577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,66 +56,36 @@\n         raise ValueError(\"OpenAI API key is missing. Make sure it's set in the .env file.\")\n \n     messages = [\n         {\"role\": \"system\", \"content\": \"You are an expert Python programmer. Suggest appropriate titles for the following scripts.\"},\n-        {\n-            \"role\": \"system\",\n-            \"content\": \"You are an expert Python programmer. Suggest appropriate titles for the following scripts.\",\n-        },\n-        {\n-            \"role\": \"user\",\n-            \"content\": \"\\n\\n\".join(\n-                f\"Script {i+1}:\\n{content[:1000]}\"\n-                for i, content in enumerate(script_contents)\n-            ),\n-        },\n+        {\"role\": \"user\", \"content\": \"\\n\\n\".join(f\"Script {i+1}:\\n{content[:1000]}\" for i, content in enumerate(script_contents))}\n     ]\n \n     try:\n-        # Make the batch request to OpenAI\n-        response = client.chat.completions.create(\n-            model=\"gpt-4o\", messages=messages, max_tokens=300\n-        )\n-\n-        # Parse the response to extract the titles for each script\n+        response = client.chat.completions.create(model=\"gpt-4o\", messages=messages, max_tokens=300)\n         response_text = response.choices[0].message.content.strip()\n-        titles = []\n+        titles = [line.strip() if re.match(r\"\\d+\\.\", line.strip()) else f\"{i+1}. Untitled\" for i, line in enumerate(response_text.split(\"\\n\"))]\n \n-        # Process each line of the response text to extract titles\n-        for i, line in enumerate(response_text.split(\"\\n\")):\n-            line = line.strip()\n-            if line and re.match(\n-                r\"\\d+\\.\", line\n-            ):  # Look for lines that start with a number followed by a dot\n-                titles.append(line)\n-            else:\n-                titles.append(f\"{i+1}. Untitled\")\n-\n         if len(titles) < len(script_contents):\n-            titles.extend(\n-                [f\"{i+1}. Untitled\" for i in range(len(titles), len(script_contents))]\n-            )\n+            titles.extend([f\"{i+1}. Untitled\" for i in range(len(titles), len(script_contents))])\n \n         return titles\n     except Exception as e:\n         print(f\"Error during batch processing: {e}\")\n         return [f\"{i+1}. Untitled\" for i in range(len(script_contents))]\n \n-\n # Function to process files in batches and get their details\n def suggest_script_titles_batch(file_paths, batch_size=10):\n     results = []\n \n     for i in range(0, len(file_paths), batch_size):\n-        batch_paths = file_paths[i : i + batch_size]\n+        batch_paths = file_paths[i:i + batch_size]\n         batch_contents = []\n \n-        # Read each file in the batch\n         for file_path in batch_paths:\n             try:\n                 with open(file_path, \"r\", encoding=\"utf-8\") as file:\n-                    content = file.read()\n-                batch_contents.append(content)\n+                    batch_contents.append(file.read())\n             except Exception as e:\n                 print(f\"Error reading {file_path}: {e}\")\n                 batch_contents.append(\"\")\n \n"
                },
                {
                    "date": 1757089252160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,70 +88,46 @@\n             except Exception as e:\n                 print(f\"Error reading {file_path}: {e}\")\n                 batch_contents.append(\"\")\n \n-        # Get titles from OpenAI\n         batch_titles = get_openai_batch_titles(batch_contents)\n \n-        # Get file details\n         for file_path, title, content in zip(batch_paths, batch_titles, batch_contents):\n             category = categorize_script(content, os.path.basename(file_path))\n             documentation = generate_pydocgen(file_path)\n-            results.append(\n-                {\n-                    \"File Name\": os.path.basename(file_path),\n-                    \"Categories\": category,\n-                    \"Suggested Title\": title,\n-                    \"Documentation\": documentation,\n-                    \"Path\": file_path,\n-                }\n-            )\n-            # Print in the preferred format\n+            results.append({\n+                \"File Name\": os.path.basename(file_path),\n+                \"Categories\": category,\n+                \"Suggested Title\": title,\n+                \"Documentation\": documentation,\n+                \"Path\": file_path,\n+            })\n             print(f\"Suggested category for {os.path.basename(file_path)}: {category}\")\n             print(f\"Suggested title for {os.path.basename(file_path)}: {title}\")\n \n     return results\n \n-\n # Function to scan a directory for .py files and output the results to a CSV\n-def process_directory_with_batching(\n-    directory_path, batch_size=10, output_csv=\"output.csv\"\n-):\n-    file_paths = [\n-        os.path.join(root, file)\n-        for root, _, files in os.walk(directory_path)\n-        for file in files\n-        if file.endswith(\".py\")\n-    ]\n+def process_directory_with_batching(directory_path, batch_size=10, output_csv=\"output.csv\"):\n+    file_paths = [os.path.join(root, file) for root, _, files in os.walk(directory_path) for file in files if file.endswith(\".py\")]\n \n     if not file_paths:\n         print(\"No Python files found in the specified directory.\")\n         return\n \n     results = suggest_script_titles_batch(file_paths, batch_size=batch_size)\n \n-    # Write results to CSV\n     with open(output_csv, \"w\", newline=\"\", encoding=\"utf-8\") as csvfile:\n-        fieldnames = [\n-            \"File Name\",\n-            \"Categories\",\n-            \"Suggested Title\",\n-            \"Documentation\",\n-            \"Path\",\n-        ]\n+        fieldnames = [\"File Name\", \"Categories\", \"Suggested Title\", \"Documentation\", \"Path\"]\n         writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n         writer.writeheader()\n-        for result in results:\n-            writer.writerow(result)\n+        writer.writerows(results)\n \n     print(f\"Results have been written to {output_csv}\")\n \n-\n # Example usage\n if __name__ == \"__main__\":\n-    directory_path = \"/Users/steven/Documents/python/clean\"  # Your target directory\n-    batch_size = 10  # Number of scripts to process at a time\n-    output_csv = \"/Users/steven/Documents/python/output.csv\"  # Output CSV file path\n+    directory_path = \"/Users/steven/Documents/python/clean\"\n+    batch_size = 10\n+    output_csv = \"/Users/steven/Documents/python/output.csv\"\n \n-    process_directory_with_batching(\n-        directory_path, batch_size=batch_size, output_csv=output_csv\n-    )\n+    process_directory_with_batching(directory_path, batch_size=batch_size, output_csv=output_csv)\n"
                }
            ],
            "date": 1757089222998,
            "name": "Commit-0",
            "content": "import os\nimport csv\nimport re\nimport subprocess\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\n\n# Load environment variables from the specified .env file\nload_dotenv(\"~/.env\")\n\n# Initialize OpenAI client\nclient = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n\n# Function to categorize scripts based on content\ndef categorize_script(content, file_name):\n    content_lower = content.lower()\n    file_name_lower = file_name.lower()\n    \n    if \"image\" in content_lower or \"convert\" in file_name_lower:\n        return \"Image Conversion and Upscaling Script\"\n    if \"backup\" in content_lower or \"autopep8\" in content_lower:\n        return \"File Backup and Autopep8 Formatting\"\n    if \"scan\" in content_lower or \"directory\" in content_lower:\n        return \"Directory Scan for Large Images\"\n    if (\n        \"cleanup\" in content.lower()\n        or \"virtualenv\" in content.lower()\n        or \"venv\" in content.lower()\n    ):\n        return \"Virtual Environment Cleanup Manager\"\n    if \"google\" in content.lower() or \"drive\" in content.lower():\n        return \"Google Drive Link Converter\"\n    if \"quiz\" in file_name.lower():\n        if \"tts\" in file_name.lower():\n            return \"Trivia Quiz Generator\"\n        else:\n            return \"Image Upscaling and YouTube Content Generator\"\n    if \"vance\" in file_name.lower() or \"ai\" in content.lower():\n        return \"Image Upscaling with Vance AI API\"\n    if \"speech\" in content.lower() or \"text-to-speech\" in content.lower():\n        return \"Text-to-Speech Speech Generation\"\n    if \"transcribe\" in content.lower() or \"audio\" in content.lower():\n        return \"Speech Transcription\"\n    if \"analyze\" in content.lower() or \"lyrics\" in content.lower():\n        return \"Lyrics Analyzer Assistant\"\n\n    # Default category if none matched\n    return \"General Script\"\n\n\n# Function to generate documentation using pydocgen\ndef generate_pydocgen(file_path):\n    try:\n        # Generate documentation using the pydocgen command-line tool\n        result = subprocess.run([\"pydocgen\", file_path], capture_output=True, text=True)\n        # Return the generated documentation if successful\n        if result.returncode == 0:\n            return result.stdout\n        else:\n            print(f\"pydocgen failed for {file_path}: {result.stderr}\")\n            return \"Documentation generation failed\"\n    except Exception as e:\n        print(f\"Error generating documentation for {file_path}: {e}\")\n        return \"Documentation generation failed\"\n\n\n# Function to get script titles using OpenAI API\ndef get_openai_batch_titles(script_contents):\n    if not openai.api_key:\n        raise ValueError(\n            \"OpenAI API key is missing. Make sure it's set in the .env file.\"\n        )\n\n    # Prepare messages for the batch request\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": \"You are an expert Python programmer. Suggest appropriate titles for the following scripts.\",\n        },\n        {\n            \"role\": \"user\",\n            \"content\": \"\\n\\n\".join(\n                f\"Script {i+1}:\\n{content[:1000]}\"\n                for i, content in enumerate(script_contents)\n            ),\n        },\n    ]\n\n    try:\n        # Make the batch request to OpenAI\n        response = client.chat.completions.create(\n            model=\"gpt-4o\", messages=messages, max_tokens=300\n        )\n\n        # Parse the response to extract the titles for each script\n        response_text = response.choices[0].message.content.strip()\n        titles = []\n\n        # Process each line of the response text to extract titles\n        for i, line in enumerate(response_text.split(\"\\n\")):\n            line = line.strip()\n            if line and re.match(\n                r\"\\d+\\.\", line\n            ):  # Look for lines that start with a number followed by a dot\n                titles.append(line)\n            else:\n                titles.append(f\"{i+1}. Untitled\")\n\n        if len(titles) < len(script_contents):\n            titles.extend(\n                [f\"{i+1}. Untitled\" for i in range(len(titles), len(script_contents))]\n            )\n\n        return titles\n    except Exception as e:\n        print(f\"Error during batch processing: {e}\")\n        return [f\"{i+1}. Untitled\" for i in range(len(script_contents))]\n\n\n# Function to process files in batches and get their details\ndef suggest_script_titles_batch(file_paths, batch_size=10):\n    results = []\n\n    for i in range(0, len(file_paths), batch_size):\n        batch_paths = file_paths[i : i + batch_size]\n        batch_contents = []\n\n        # Read each file in the batch\n        for file_path in batch_paths:\n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as file:\n                    content = file.read()\n                batch_contents.append(content)\n            except Exception as e:\n                print(f\"Error reading {file_path}: {e}\")\n                batch_contents.append(\"\")\n\n        # Get titles from OpenAI\n        batch_titles = get_openai_batch_titles(batch_contents)\n\n        # Get file details\n        for file_path, title, content in zip(batch_paths, batch_titles, batch_contents):\n            category = categorize_script(content, os.path.basename(file_path))\n            documentation = generate_pydocgen(file_path)\n            results.append(\n                {\n                    \"File Name\": os.path.basename(file_path),\n                    \"Categories\": category,\n                    \"Suggested Title\": title,\n                    \"Documentation\": documentation,\n                    \"Path\": file_path,\n                }\n            )\n            # Print in the preferred format\n            print(f\"Suggested category for {os.path.basename(file_path)}: {category}\")\n            print(f\"Suggested title for {os.path.basename(file_path)}: {title}\")\n\n    return results\n\n\n# Function to scan a directory for .py files and output the results to a CSV\ndef process_directory_with_batching(\n    directory_path, batch_size=10, output_csv=\"output.csv\"\n):\n    file_paths = [\n        os.path.join(root, file)\n        for root, _, files in os.walk(directory_path)\n        for file in files\n        if file.endswith(\".py\")\n    ]\n\n    if not file_paths:\n        print(\"No Python files found in the specified directory.\")\n        return\n\n    results = suggest_script_titles_batch(file_paths, batch_size=batch_size)\n\n    # Write results to CSV\n    with open(output_csv, \"w\", newline=\"\", encoding=\"utf-8\") as csvfile:\n        fieldnames = [\n            \"File Name\",\n            \"Categories\",\n            \"Suggested Title\",\n            \"Documentation\",\n            \"Path\",\n        ]\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        for result in results:\n            writer.writerow(result)\n\n    print(f\"Results have been written to {output_csv}\")\n\n\n# Example usage\nif __name__ == \"__main__\":\n    directory_path = \"/Users/steven/Documents/python/clean\"  # Your target directory\n    batch_size = 10  # Number of scripts to process at a time\n    output_csv = \"/Users/steven/Documents/python/output.csv\"  # Output CSV file path\n\n    process_directory_with_batching(\n        directory_path, batch_size=batch_size, output_csv=output_csv\n    )\n"
        }
    ]
}